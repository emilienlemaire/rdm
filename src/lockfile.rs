use std::{fs::File, io::Write, path::PathBuf};

use rdm_macros::{FromError, ToDoc};
use serde::{Deserialize, Serialize};

use crate::config::Config;

#[derive(Debug, FromError, ToDoc)]
#[doc_prefix = "Error while using `rdm.lock'"]
pub(crate) enum LockFileError {
    #[doc_to_string]
    IoError(std::io::Error),
    #[doc_to_string]
    TomlDeError(toml::de::Error),
    #[doc_to_string]
    GitError(git2::Error),
    #[doc_to_string]
    TomlSerError(toml::ser::Error),
    #[doc_to_string]
    EnvError(std::env::VarError),
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct TomlConfig {
    pub(crate) repo_path: String,
    pub(crate) worktree_path: String,
    pub(crate) revision: u32,
}

impl TomlConfig {
    pub(crate) fn new(
        repo_path: &Option<String>,
        worktree: &Option<&str>,
    ) -> Result<TomlConfig, LockFileError> {
        let repo_path = match repo_path {
            None => {
                let current_dir = std::env::current_dir()?;
                current_dir.to_str().unwrap().to_string()
            }
            Some(path) => path.to_string(),
        };

        let worktree_path = match worktree {
            None => {
                let p = std::env::var("HOME")?;
                std::fs::canonicalize(p)?.to_string_lossy().to_string()
            }
            Some(path) => {
                let p = path.to_string();
                std::fs::canonicalize(p)?.to_string_lossy().to_string()
            }
        };

        Ok(Self {
            repo_path,
            worktree_path,
            revision: 1,
        })
    }

    pub(crate) fn save(
        self: &TomlConfig,
        path: &PathBuf,
    ) -> Result<(), LockFileError> {
        let str = r#"# This file is automatically @generated by rdm.
# It is not intended for manual editing."#
            .to_string();

        let toml = toml::to_string(self)?;

        let str = format!("{}\n{}", str, toml);
        if !path.exists() {
            let mut lock_file = File::create(path)?;
            lock_file.flush()?;
        }

        let mut lock_file = std::fs::OpenOptions::new()
            .write(true)
            .truncate(true)
            .open(path)?;
        lock_file.write_all(str.as_bytes())?;
        lock_file.flush()?;

        Ok(())
    }

    pub(crate) fn load(path: &PathBuf) -> Result<TomlConfig, LockFileError> {
        let str = std::fs::read_to_string(path)?;

        Ok(toml::from_str(str.as_str())?)
    }
}

pub(crate) fn increment_revision(config: &Config) -> Result<(), LockFileError> {
    let mut lockfile_path = config.config_path.clone();
    lockfile_path.push("rdm.lock");

    let lockfile = std::fs::read_to_string(&lockfile_path)?;

    let conf = toml::de::from_str::<TomlConfig>(lockfile.as_str())?;

    let new_config = TomlConfig {
        revision: conf.revision + 1,
        ..conf
    };

    new_config.save(&lockfile_path)?;

    let repo = &config.repo;
    let mut index = repo.index()?;

    let worktree_abs = std::fs::canonicalize(&config.worktree_path)?;
    let lockfile_abs = std::fs::canonicalize(&lockfile_path)?;

    index.add_path(
        &pathdiff::diff_paths(&lockfile_abs, &worktree_abs).unwrap(),
    )?;
    index.write()?;

    Ok(())
}
